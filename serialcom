#!/usr/bin/env python3
"""
SerialCom - Graphical interface for serial communication via picocom
Version: 1.1
"""

import sys
import os
import subprocess
import glob
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QComboBox, QPushButton, QGroupBox, QFormLayout, QMessageBox,
    QTextEdit, QDialog
)
from PyQt6.QtCore import Qt, QProcess, pyqtSignal
from PyQt6.QtGui import QFont, QTextCursor, QKeyEvent

# Application version
VERSION = "1.1"

try:
    from PyQt6.QtSerialPort import QSerialPortInfo
    SERIAL_PORT_AVAILABLE = True
except ImportError:
    SERIAL_PORT_AVAILABLE = False


class TerminalWidget(QTextEdit):
    """Custom terminal widget for displaying picocom output and handling input"""
    
    send_input = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setReadOnly(False)
        self.setFont(QFont("Monospace", 10))
        self.input_buffer = ""
        self.command_start_pos = 0
        
        # Apply terminal styling
        self.setStyleSheet("""
            QTextEdit {
                background-color: #1e1e2e;
                color: #cdd6f4;
                border: none;
                padding: 10px;
            }
        """)
        
    def keyPressEvent(self, event: QKeyEvent):
        """Handle key press events for terminal input"""
        # Get the key
        key = event.key()
        text = event.text()
        
        # Handle special keys
        if key == Qt.Key.Key_Return or key == Qt.Key.Key_Enter:
            # Send newline
            self.send_input.emit('\n')
            super().keyPressEvent(event)
        elif key == Qt.Key.Key_Backspace:
            # Allow backspace
            super().keyPressEvent(event)
        elif key == Qt.Key.Key_Tab:
            # Send tab
            self.send_input.emit('\t')
            super().keyPressEvent(event)
        elif event.modifiers() & Qt.KeyboardModifier.ControlModifier:
            # Handle Ctrl+A and other control sequences
            if key == Qt.Key.Key_A:
                self.send_input.emit('\x01')  # Ctrl+A
            elif key == Qt.Key.Key_X:
                self.send_input.emit('\x18')  # Ctrl+X
            elif key == Qt.Key.Key_C:
                self.send_input.emit('\x03')  # Ctrl+C
            elif key == Qt.Key.Key_D:
                self.send_input.emit('\x04')  # Ctrl+D
            elif key == Qt.Key.Key_H:
                self.send_input.emit('\x08')  # Ctrl+H
            else:
                super().keyPressEvent(event)
        elif text:
            # Send regular character
            self.send_input.emit(text)
            super().keyPressEvent(event)
        else:
            super().keyPressEvent(event)
    
    def append_output(self, text):
        """Append output text to the terminal"""
        self.moveCursor(QTextCursor.MoveOperation.End)
        self.insertPlainText(text)
        self.moveCursor(QTextCursor.MoveOperation.End)


class TerminalDialog(QDialog):
    """Dialog window containing the embedded terminal"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("SerialCom Terminal")
        self.setMinimumSize(800, 600)
        self.process = None
        self.sudo_process = None
        
        self.init_ui()
        
    def init_ui(self):
        """Initialize the terminal dialog UI"""
        layout = QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Terminal widget
        self.terminal = TerminalWidget()
        self.terminal.send_input.connect(self.send_to_process)
        layout.addWidget(self.terminal)
        
        # Control buttons
        button_layout = QHBoxLayout()
        button_layout.setContentsMargins(10, 5, 10, 10)
        
        self.disconnect_btn = QPushButton("DISCONNECT")
        self.disconnect_btn.setMinimumHeight(35)
        self.disconnect_btn.setFont(QFont("Sans Serif", 10, QFont.Weight.Bold))
        self.disconnect_btn.clicked.connect(self.disconnect)
        self.disconnect_btn.setStyleSheet("""
            QPushButton {
                background-color: #f38ba8;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #f26d8f;
            }
            QPushButton:pressed {
                background-color: #d95a7a;
            }
        """)
        
        button_layout.addStretch()
        button_layout.addWidget(self.disconnect_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
        
    def start_picocom(self, cmd):
        """Start picocom process with sudo"""
        # Create the process
        self.process = QProcess(self)
        self.process.readyReadStandardOutput.connect(self.handle_stdout)
        self.process.readyReadStandardError.connect(self.handle_stderr)
        self.process.finished.connect(self.process_finished)
        
        # Build sudo command
        picocom_cmd = ' '.join(cmd)
        full_cmd = ['sudo', '-S'] + cmd
        
        # Start process
        self.terminal.append_output(f"Starting: {picocom_cmd}\n")
        self.terminal.append_output("Enter sudo password if prompted...\n\n")
        
        self.process.start(full_cmd[0], full_cmd[1:])
        
        if not self.process.waitForStarted(3000):
            self.terminal.append_output("\n[ERROR] Failed to start picocom\n")
            return False
        
        return True
    
    def send_to_process(self, text):
        """Send input to the picocom process"""
        if self.process and self.process.state() == QProcess.ProcessState.Running:
            self.process.write(text.encode())
    
    def handle_stdout(self):
        """Handle standard output from picocom"""
        if self.process:
            data = self.process.readAllStandardOutput()
            text = bytes(data).decode('utf-8', errors='replace')
            self.terminal.append_output(text)
    
    def handle_stderr(self):
        """Handle standard error from picocom"""
        if self.process:
            data = self.process.readAllStandardError()
            text = bytes(data).decode('utf-8', errors='replace')
            self.terminal.append_output(text)
    
    def process_finished(self, exit_code, exit_status):
        """Handle process termination"""
        self.terminal.append_output(f"\n\n[Process terminated with exit code {exit_code}]\n")
        self.terminal.append_output("You can close this window.\n")
        self.disconnect_btn.setText("CLOSE")
    
    def disconnect(self):
        """Disconnect from serial port"""
        if self.process and self.process.state() == QProcess.ProcessState.Running:
            # Send Ctrl+A Ctrl+X to exit picocom gracefully
            self.process.write(b'\x01\x18')
            
            # Wait a bit for graceful exit
            if not self.process.waitForFinished(2000):
                # Force terminate if needed
                self.process.terminate()
                if not self.process.waitForFinished(1000):
                    self.process.kill()
        
        self.close()
    
    def closeEvent(self, event):
        """Handle window close event"""
        if self.process and self.process.state() == QProcess.ProcessState.Running:
            reply = QMessageBox.question(
                self,
                'Confirm Exit',
                'Connection is still active. Disconnect and close?',
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                self.disconnect()
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()


class SerialTerminalGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(f"SerialCom v{VERSION}")
        self.setFixedSize(550, 600)
        self.terminal_dialog = None
        self.init_ui()
        self.apply_styles()

    def init_ui(self):
        """Initialize the user interface"""
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Main layout
        main_layout = QVBoxLayout()
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(20, 20, 20, 20)

        # Port configuration group
        port_group = QGroupBox("Port Configuration")
        port_layout = QFormLayout()
        port_layout.setVerticalSpacing(15)
        port_layout.setContentsMargins(10, 15, 10, 10)

        # Port type
        self.port_type = QComboBox()
        self.port_type.addItems(['Serial (/dev/ttyS*)', 'USB (/dev/ttyUSB*)', 'All Ports'])
        self.port_type.setCurrentIndex(1)
        self.port_type.currentIndexChanged.connect(self.update_port_list)
        port_layout.addRow("Port Type:", self.port_type)

        # Specific port
        self.port = QComboBox()
        port_layout.addRow("Port:", self.port)

        port_group.setLayout(port_layout)
        main_layout.addWidget(port_group)

        # Communication parameters group
        comm_group = QGroupBox("Communication Parameters")
        comm_layout = QFormLayout()
        comm_layout.setVerticalSpacing(15)
        comm_layout.setContentsMargins(10, 15, 10, 10)

        # Baud Rate - MAIN FIELD
        velocity_label = QLabel("Baud Rate:")
        velocity_font = QFont("Sans Serif", 10, QFont.Weight.Bold)
        velocity_label.setFont(velocity_font)

        self.baudrate = QComboBox()
        self.baudrate.addItems([
            '300', '1200', '2400', '4800', '9600', '19200',
            '38400', '57600', '115200', '230400', '460800', '921600'
        ])
        self.baudrate.setCurrentText('9600')
        comm_layout.addRow(velocity_label, self.baudrate)

        # Data bits
        self.databits = QComboBox()
        self.databits.addItems(['5', '6', '7', '8'])
        self.databits.setCurrentText('8')
        comm_layout.addRow("Data Bits:", self.databits)

        # Parity
        self.parity = QComboBox()
        self.parity.addItems(['None', 'Even', 'Odd'])
        self.parity.setCurrentText('None')
        comm_layout.addRow("Parity:", self.parity)

        # Stop bits
        self.stopbits = QComboBox()
        self.stopbits.addItems(['1', '2'])
        self.stopbits.setCurrentText('1')
        comm_layout.addRow("Stop Bits:", self.stopbits)

        # Flow control
        self.flow = QComboBox()
        self.flow.addItems(['None', 'Hardware (RTS/CTS)', 'Software (XON/XOFF)'])
        self.flow.setCurrentText('None')
        comm_layout.addRow("Flow Control:", self.flow)

        comm_group.setLayout(comm_layout)
        main_layout.addWidget(comm_group)

        # Connect button
        self.connect_btn = QPushButton("CONNECT")
        self.connect_btn.setMinimumHeight(45)
        self.connect_btn.setFont(QFont("Sans Serif", 11, QFont.Weight.Bold))
        self.connect_btn.clicked.connect(self.connect)
        main_layout.addWidget(self.connect_btn)

        # Status
        self.status_label = QLabel("Ready to connect")
        self.status_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt; padding: 5px;")
        main_layout.addWidget(self.status_label)

        central_widget.setLayout(main_layout)

        # Update port list
        self.update_port_list()

    def get_arrow_icon_path(self):
        """Get the path to arrow_down.svg for different installation types"""
        # Check for Flatpak
        if os.path.exists('/app/share/io.github.benjamimgois.serialcom/arrow_down.svg'):
            return '/app/share/io.github.benjamimgois.serialcom/arrow_down.svg'
        # Check for AppImage
        elif os.environ.get('APPDIR'):
            appdir = os.environ.get('APPDIR')
            return os.path.join(appdir, 'usr/share/serialcom/arrow_down.svg')
        # Local installation or development
        else:
            # Try current directory first
            local_path = os.path.join(os.path.dirname(__file__), 'arrow_down.svg')
            if os.path.exists(local_path):
                return local_path
            # Try assets directory
            assets_path = os.path.join(os.path.dirname(__file__), 'assets/arrow_down.svg')
            if os.path.exists(assets_path):
                return assets_path
            # Fallback
            return local_path

    def apply_styles(self):
        """Apply modern light theme to the application"""
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f5f5f5;
            }
            QGroupBox {
                font-weight: bold;
                border: 2px solid #d0d0d0;
                border-radius: 8px;
                margin-top: 10px;
                padding-top: 15px;
                background-color: #ffffff;
                color: #2c2c2c;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px;
                color: #5a5a5a;
            }
            QComboBox {
                border: 2px solid #d0d0d0;
                border-radius: 6px;
                padding: 6px 28px 6px 10px;
                background-color: #ffffff;
                min-height: 28px;
                color: #2c2c2c;
                font-size: 10pt;
            }
            QComboBox::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 25px;
                border-left: 1px solid #d0d0d0;
                border-top-right-radius: 5px;
                border-bottom-right-radius: 5px;
                background-color: transparent;
            }
            QComboBox::down-arrow {
                image: url(""" + self.get_arrow_icon_path() + """);
                width: 12px;
                height: 12px;
            }
            QComboBox:hover {
                border: 2px solid #a0a0a0;
                background-color: #fafafa;
            }
            QComboBox:focus {
                border: 2px solid #808080;
            }
            QComboBox QAbstractItemView {
                border: 2px solid #d0d0d0;
                background-color: #ffffff;
                selection-background-color: #e0e0e0;
                selection-color: #2c2c2c;
                color: #2c2c2c;
                padding: 4px;
                outline: none;
            }
            QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 8px;
                padding: 12px;
                font-weight: bold;
                font-size: 11pt;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:pressed {
                background-color: #3d8b40;
            }
            QLabel {
                color: #2c2c2c;
            }
            QFormLayout QLabel {
                color: #4a4a4a;
            }
            QMessageBox {
                background-color: #ffffff;
            }
            QMessageBox QLabel {
                color: #2c2c2c;
                font-size: 10pt;
            }
            QMessageBox QPushButton {
                background-color: #4caf50;
                color: #ffffff;
                border: none;
                border-radius: 6px;
                padding: 8px 16px;
                min-width: 80px;
            }
            QMessageBox QPushButton:hover {
                background-color: #45a049;
            }
        """)

    def update_port_list(self):
        """Update the list of available ports"""
        self.port.clear()

        port_type = self.port_type.currentText()
        ports = []

        if SERIAL_PORT_AVAILABLE and 'All' in port_type:
            # Use QSerialPortInfo to detect all ports
            available_ports = QSerialPortInfo.availablePorts()
            ports = [port.portName() for port in available_ports]
            ports = [f"/dev/{p}" for p in ports]
        else:
            # Use glob to search for ports
            if 'Serial' in port_type:
                pattern = '/dev/ttyS*'
            elif 'USB' in port_type:
                pattern = '/dev/ttyUSB*'
            else:  # All
                ports_s = sorted(glob.glob('/dev/ttyS*'))
                ports_usb = sorted(glob.glob('/dev/ttyUSB*'))
                ports = ports_s + ports_usb

            if not ports:
                ports = sorted(glob.glob(pattern))

        if ports:
            self.port.addItems(ports)
            self.status_label.setText(f"{len(ports)} port(s) found")
            self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt; padding: 5px;")
        else:
            self.port.addItem("No ports found")
            self.status_label.setText("No serial ports available")
            self.status_label.setStyleSheet("color: #fab387; font-size: 10pt; padding: 5px;")

    def build_picocom_command(self):
        """Build the picocom command with configured parameters"""
        port = self.port.currentText()

        if 'No ports found' in port or not port:
            return None

        baudrate = self.baudrate.currentText()
        databits = self.databits.currentText()

        # Parity
        parity_map = {'None': 'n', 'Even': 'e', 'Odd': 'o'}
        parity = parity_map[self.parity.currentText()]

        stopbits = self.stopbits.currentText()

        # Flow control
        flow_type = self.flow.currentText()
        if 'Hardware' in flow_type:
            flow = 'h'
        elif 'Software' in flow_type:
            flow = 's'
        else:
            flow = 'n'

        # Picocom command
        cmd = [
            'picocom',
            '-b', baudrate,
            '-d', databits,
            '-p', parity,
            '-f', flow,
            port
        ]

        # Add stop bits if 2
        if stopbits == '2':
            cmd.insert(-1, '-y')
            cmd.insert(-1, '2')

        return cmd

    def connect(self):
        """Connect to the serial port using embedded terminal"""
        # Check if picocom is installed
        try:
            subprocess.run(['which', 'picocom'], check=True, capture_output=True)
        except subprocess.CalledProcessError:
            QMessageBox.critical(
                self,
                "Error",
                "picocom is not installed.\n\n"
                "Install with:\nsudo pacman -S picocom"
            )
            return

        # Build command
        cmd = self.build_picocom_command()

        if not cmd:
            QMessageBox.warning(
                self,
                "Warning",
                "Select a valid serial port"
            )
            return

        self.status_label.setText("Opening terminal...")
        self.status_label.setStyleSheet("color: #fab387; font-size: 10pt; padding: 5px;")
        QApplication.processEvents()

        # Create and show terminal dialog
        self.terminal_dialog = TerminalDialog(self)
        
        # Start picocom
        if self.terminal_dialog.start_picocom(cmd):
            self.status_label.setText("Connected - Terminal opened")
            self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt; padding: 5px;")
            self.terminal_dialog.exec()
            
            # Reset status after terminal closes
            self.status_label.setText("Ready to connect")
            self.status_label.setStyleSheet("color: #a6e3a1; font-size: 10pt; padding: 5px;")
        else:
            self.status_label.setText("Connection error")
            self.status_label.setStyleSheet("color: #f38ba8; font-size: 10pt; padding: 5px;")


def main():
    app = QApplication(sys.argv)

    # Set default font
    font = QFont("Sans Serif", 9)
    app.setFont(font)

    window = SerialTerminalGUI()
    window.show()

    sys.exit(app.exec())


if __name__ == '__main__':
    main()
